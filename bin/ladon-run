#!/usr/bin/env ruby

require 'pry'
require 'ladon'

ridiculous_banner =
" _           _
| | __ _  __| | ___  _ __            _ __ _   _ _ __  _ __   ___ _ __
| |/ _` |/ _` |/ _ \\| '_ \\   _____  | '__| | | | '_ \\| '_ \\ / _ \\ '__|
| | (_| | (_| | (_) | | | | |_____| | |  | |_| | | | | | | |  __/ |
|_|\\__,_|\\__,_|\\___/|_| |_|         |_|   \\__,_|_| |_|_| |_|\\___|_|   "

def make_opt_parser
  vals = Struct.new(:automation_path, :interactive_after, :review, :flags).new
  parser = OptionParser.new do |opts|
    opts.banner = 'Usage: ladon-run [options]'

    opts.on('-a PATH',
            '--automation PATH',
            String,
            'Path to the automation script to be executed') do |val|
      vals.automation_path = val
    end

    opts.on('-i PHASE_LIST',
            '--interactive_after PHASE_LIST',
            String,
            'Comma-separated list of phase names that the runner should perform and then enter interactive mode.') do |val|
      vals.interactive_after = val.split(',').map { |phase| phase.strip.to_sym }
    end

    opts.on('-f FLAGS',
            '--flags FLAGS',
            String,
            'Comma-separated list of name:value pairs') do |val|
      vals.flags = Hash[val.split(',').map {|el| el.split ':'}]
    end

    opts.on('-r', '--review', 'Pause after automation completes') do
      vals.review = true
    end

    opts.on('-h', '--help', 'Prints this help message') do
      puts opts
      exit
    end
  end
  [vals, parser]
end

def load_automation_source(auto_loc)
  require_relative File.expand_path(auto_loc, Dir.pwd) # load that path
end

def select_automation_class
  # Detect all Automation subclasses
  detected_automations = ObjectSpace.each_object(Ladon::Automator::Automation.singleton_class)

  # Filter to only those Automation subclasses that are marked executable
  executable_automations = detected_automations.select {|cls| cls.respond_to?(:abstract?) && !cls.abstract?}

  # Select a single executable Automation subclass to run
  raise StandardError, 'No non-abstract Automation subclasses detected! Exiting...' if executable_automations.empty?
  return executable_automations[0] if executable_automations.size == 1

  puts "\nPlease select the Automation you wish to run by entering one of the following numbers:"
  executable_automations.each_with_index { |cls, idx| puts "\t#{idx + 1}. #{cls.name}" }
  begin
    idx = gets.to_i
    raise StandardError unless idx > 0 && idx < executable_automations.size
    return executable_automations[idx]
  rescue
    puts 'Nope. Try again.'
    retry
  end
end

def configure_automation(options)
  cfg = Ladon::Automator::Config.new
  # TODO: options? may conflict with the load from above
  return cfg
end

def print_separator_line(sep = '*')
  puts sep.to_s * 80
end

options, parser = make_opt_parser
parser.parse!(ARGV)

raise StandardError, 'Automation not specified!' unless options.automation_path
options.interactive_after = [] unless options.interactive_after.is_a?(Array)
options.flags = {} unless options.flags.is_a?(Hash)

load_automation_source(options.automation_path)
target_automation = select_automation_class
automation = nil

begin
  print_separator_line
  puts ridiculous_banner
  print_separator_line

  puts "\nStarting: #{target_automation.name}"
  automation = target_automation.new(configure_automation(options))
  target_automation.all_phases.each_with_index do |phase_name, idx|
    print "Beginning phase: #{phase_name}..."
    automation.run(to_index: idx) # this is the interesting line
    puts 'complete!'

    if options.interactive_after.include?(phase_name)
      puts ''
      print_separator_line('-')
      puts "\tStarting interactive mode\n"

      binding.pry

      puts "\n\tInteractive mode exited, continuing..."
      print_separator_line('-')
      puts ''
    end
  end
  puts "\nExecution complete"
rescue => ex
  puts "\nAutomation Error: #{ex}"
  puts ex.backtrace
end

if options.review
  puts 'Entering interactive review mode'
  binding.pry
  puts 'exiting...'
end
