#!/usr/bin/env ruby
require 'optparse'
require 'pathname'
require 'pp'
require 'pry'
require 'ladon'

class LadonAutomationRunner < Ladon::Automator::Automation
  ARGV_FLAG = :argv
  RIDICULOUS_BANNER =
    " _           _
| | __ _  __| | ___  _ __            _ __ _   _ _ __  _ __   ___ _ __
| |/ _` |/ _` |/ _ \\| '_ \\   _____  | '__| | | | '_ \\| '_ \\ / _ \\ '__|
| | (_| | (_| | (_) | | | | |_____| | |  | |_| | | | | | | |  __/ |
|_|\\__,_|\\__,_|\\___/|_| |_|         |_|   \\__,_|_| |_|_| |_|\\___|_|   ".freeze
  AUTOMATION_DIR_BASENAME = 'automations'.freeze
  RESULTS_FLAGS = { type: 'res_type', file: 'res_file' }.freeze

  # Ladon-run uses a setup-execute-teardown cycle.
  # If setup results in a non-success status, execute is skipped but teardown will still occur.
  def self.phases
    [
      Ladon::Automator::Phase.new(:setup, required: true),
      Ladon::Automator::Phase.new(:execute, required: true, validator: -> automation { automation.result.success? }),
      Ladon::Automator::Phase.new(:teardown, required: true)
    ]
  end

  def setup
    argv_given = flags.get(ARGV_FLAG, default_to: nil)
    halting_assert('ARGV flag must be provided') do
      argv_given.is_a?(Array)
    end

    halting_assert('Options provided must be valid') do
      @options = _parse_options(flags: argv_given)
      _validate_options?
    end

    _include_load_path

    halting_assert('Must be able to load a file at the specified path') do
      _load_automation_source
    end

    @target_automation_class = _select_automation_class
  end

  def execute
    _print_separator_line
    puts RIDICULOUS_BANNER
    _print_separator_line

    puts "\nStarting: #{@target_automation_class.name}"

    wrapper = Class.new(@target_automation_class) do
      def self.make_phases_interactive(phase_names)
        phase_names.uniq.each do |name|
          define_method name do
            binding.pry
            super
          end
        end
      end
    end

    wrapper.make_phases_interactive(@options.interactive)
    @target_automation = wrapper.spawn(flags: @options.flags)
    @target_automation.run

    puts "\nExecution complete"
  end

  def teardown
    binding.pry if @options.nil? || @options.review
    _make_results
  end

  private

  # generate a result representation and to output it according to provided flags
  def _make_results
    result_type = @options.flags.fetch(RESULTS_FLAGS[:type], nil).to_sym
    return if result_type.nil? || !@target_automation.result.respond_to?(result_type)

    my_result = @target_automation.result.send(result_type)
    result_file = @options.flags.fetch(RESULTS_FLAGS[:file], nil)

    # handle ouptut
    if result_file.nil?
      _print_separator_line('-', ' Results ')
      puts my_result
      _print_separator_line('-')
    else
      File.write(File.expand_path(result_file), my_result)
      puts "Results written to #{File.expand_path(result_file)}"
    end
  end

  def _parse_options(flags: [])
    vals = Struct.new(:automation_path,
                      :automation_class_name,
                      :interactive,
                      :review,
                      :flags).new
    OptionParser.new do |opts|
      opts.banner = 'Usage: ladon-run [options]'

      opts.on('-a PATH',
              '--automation PATH',
              String,
              '[REQUIRED] Path to the automation script to be executed') do |val|
        vals.automation_path = val
      end

      opts.on('-s NAME',
              '--automation_class NAME',
              String,
              'Name of the Automation class to run.') do |val|
        vals.automation_class_name = val
      end

      opts.on('-i PHASE_LIST',
              '--interactive PHASE_LIST',
              String,
              'Comma-separated list of phase names to enter interactive mode BEFORE running') do |val|
        vals.interactive = val.split(',').map { |phase| phase.strip.to_sym }
      end

      opts.on('-f FLAGS',
              '--flags FLAGS',
              String,
              'Comma-separated list of name:value pairs') do |val|
        # HACK: won't work with flags that have commas in them
        vals.flags = val.split(',').map { |el| el.split(':', 2) }.to_h
      end

      opts.on('-r', '--review', 'Pause after automation completes') do
        vals.review = true
      end

      opts.on('-h', '--help', 'Prints this help message') do
        puts opts
        exit
      end
    end.parse!(flags)

    vals
  end

  # returns true if the options are valid.
  def _validate_options?
    raise StandardError, 'Automation not specified!' unless @options.automation_path
    @options.interactive = [] unless @options.interactive.is_a?(Array)
    @options.flags = {} unless @options.flags.is_a?(Hash)
    true
  end

  # Look for a conventional directory to add to the load path. This runner
  # assumes a directory structure in which all automations are located under a
  # single directory with a conventional name at the root of another directory
  # that contains all other files required for the automation to run.
  # Specifically, it is looking for a directory with the following structure:
  #
  # <project_dir>/ (this is what gets added to the load path)
  #   AUTOMATION_DIR_BASENAME/
  #     ... (the automation being run is somewhere in here)
  #   ... (any other directories and files)
  #
  # If found, the directory is added to the load path.
  def _include_load_path
    automation_absolute_path = File.expand_path(@options.automation_path)

    Pathname.new(automation_absolute_path).ascend do |path|
      if path.basename.to_s.eql?(AUTOMATION_DIR_BASENAME)
        $LOAD_PATH.unshift(path.dirname.to_s)
        break
      end
    end
  end

  def _load_automation_source
    require_relative File.expand_path(@options.automation_path, Dir.pwd) # load that path
  end

  def _select_automation_class
    # Attempt to load the specified class, if provided
    return Object.const_get(@options.automation_class_name) if @options.automation_class_name

    # Detect all Automation subclasses
    detected_automations = ObjectSpace.each_object(Ladon::Automator::Automation.singleton_class)

    # Filter to only those Automation subclasses that are marked executable
    executable_automations = detected_automations.reject(&:abstract?) - [LadonAutomationRunner]

    # Select a single executable Automation subclass to run
    raise StandardError, 'No non-abstract Automation subclasses detected! Exiting...' if executable_automations.empty?
    return executable_automations[0] if executable_automations.size == 1

    _interactive_class_select(executable_automations)
  end

  def _interactive_class_select(class_options)
    puts "\nPlease select the Automation you wish to run by entering one of the following numbers:"
    class_options.each_with_index { |cls, idx| puts "\t#{idx + 1}. #{cls.name}" }
    begin
      idx = gets.to_i
      raise StandardError unless idx > 0 && idx <= class_options.size
      return class_options[idx - 1]
    rescue
      puts 'Nope. Try again.'
      retry
    end
  end

  def _print_separator_line(sep = '*', title = '')
    line_len = 80
    half_width = (line_len - title.to_s.length) / 2.0
    puts sep.to_s * half_width.floor + title.to_s + sep.to_s * half_width.ceil
  end
end

flags = Hash[LadonAutomationRunner::ARGV_FLAG, ARGV]
runner = LadonAutomationRunner.spawn(flags: Ladon::Flags.new(in_hash: flags))
runner.run

binding.pry

puts 'ladon-run complete!'
